Author: John Jacobsen, NPX Designs, Inc. john@mail.npxdesigns.com

This project consists of the very first steps of a port of Clojure to
Python.  At the moment it is interpreted and does very little (see
file test_lisp.py for examples).  I probably shouldn't even call it PyClojure
at this point, but the name at least serves to indicate my intentions....

DEPENDENCIES

- PLY [1] (for lexing and parsing)
- Nose [2] (to run unit tests)
- Python 2.6+

WHY DO THIS?

1. I have a long-standing love of Python and am very familiar w/ its libraries
2. I am fascinated by Lisp in general and Clojure in particular, and want to 
   learn it better
3. I like compilers[3] and interpreters and want to learn more about language
   implementation in general
4. I find the long JVM startup time irritating, and never loved Java all that
   much
5. I can't find evidence that anyone else is doing this at this time.

Feel free to join in!

NEXT STEPS

- Maps
- Sets
- Lambda / fn / (# ...)
- Python interop
- Macros
- Quote (do w/ macro...?)
- loop/recur
- Defn
- Namespaces
- Real persistent data structures (currently Python lists are used)
- setup.py packaging
- ...

DONE

- Parsing and storage of trees of lists, vectors, atoms, integers,
  and integers
- 'def' and simple evaluation
- A few builtin functions


[1] http://www.dabeaz.com/ply/.  It turns out Python is actually quite serviceable
    for writing compilers, particularly for prototyping, and I'm curious how far
    one can push this.
[2] http://readthedocs.org/docs/nose/en/latest/
[3] For example, I just wrote a compiler for a small subset of Go for this
    excellent class by the author of PLY:
    http://www.dabeaz.com/chicago/compiler.html
